<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="initial-scale=1, minimum-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
    <title>五子棋AI</title>
    <style>
      body {
        word-break: break-all;
      }
    </style>
  </head>
  <body>
    <div id="gameboard"></div>
    <script src="convnet.js"></script>
    <script src="deeplearn.js"></script>
    <script src="deeplearn-model.js"></script>
    <script src="convnet-model.js"></script>
    <script src="map-model.js"></script>
    <script src="game.js"></script>
    <script src="player-ai.js"></script>
    <script src="player-ui.js"></script>
    <script src="selfplay.js"></script>
    <script>
      const WORKER_COUNT = 4;
      const learnQueue = [];
      const workers = [];
      let playedGames = 0;
      let waitingWorkers = WORKER_COUNT;
      let allWorkersReady;
      const workersReady = new Promise(r => { allWorkersReady = r });
      for (let i = 0; i < WORKER_COUNT; i++) {
        const worker = new Worker('worker.js');
        worker.onmessage = (e) => {
          const { ready, play, boardState, target, action } = e.data;
          if (ready) {
            waitingWorkers--;
            if (waitingWorkers === 0) {
              allWorkersReady();
            }
          } else if (play) {
            playedGames += play;
          } else {
            learnQueue.push({ boardState, target, action });
          }
        };
        workers.push(worker);
      }
      function broadcast (message) {
        workers.forEach(worker => worker.postMessage(message));
      }
      const model = new ConvnetModel();
      try {
        model.fromJSON(JSON.parse(localStorage.goBangCore));
      } catch (err) {}

      workersReady.then(async () => {
        broadcast({ model: model.toJSON() });
        while (true) {
          await idle();
          broadcast({ pause: learnQueue.length > 1000 });
          if (learnQueue.length === 0) {
            await new Promise(r => setTimeout(r, 100));
          } else {
            const queue = learnQueue.splice(0, 1000);
            let avgError = 0;
            let maxError = 0;
            for (const { boardState, action, target } of queue) {
              const error = model.learn(new GameState(boardState.board), action, target);
              maxError = Math.max(error, maxError);
              avgError += error / queue.length;
              await idle();
            }

            const { wins, game } = await startSelfPlay(model);
            console.log(
              queue.length,
              'plays:', playedGames,
              'pending:', learnQueue.length,
              'avgErr:', avgError.toFixed(3) - 0,
              'maxErr:', maxError.toFixed(3) - 0,
              'wins:', wins
            );
            displayUI(document.getElementById('gameboard'), game.state.board);
            const modelJson = model.toJSON();
            broadcast({ model: modelJson });
            localStorage.goBangCore = JSON.stringify(modelJson);
          }
        }
      });

      let prevIdleTime = Date.now();
      async function idle () {
        const now = Date.now()
        if (now - prevIdleTime > 100) {
          prevIdleTime = now;
          await new Promise(r => setTimeout(r, 10));
        }
      }
    </script>
  </body>
</html>

