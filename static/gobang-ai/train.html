<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf=8">
    <meta name="viewport" content="initial-scale=1, minimum-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
    <title>五子棋AI</title>
    <style>
      body {
        break-word: break-all;
      }
    </style>
  </head>
  <body>
    <div id="gameboard"></div>
    <script src="game.js"></script>
    <script src="player-ai.js"></script>
    <script>
      const HORDE_SIZE = 12;
      let horde = [];
      try {
        horde.push({
          core: JSON.parse(localStorage.goBangCore),
        });
      } catch (err) {}
      (async () => {
        let epoch = 0;
        let maxRounds = 20;
        while (true) {
          await new Promise(r => setTimeout(r, 10));
          while (horde.length < HORDE_SIZE) {
            horde.push({
              core: createRandomCore(),
            });
          }
          const winnerStat = [0, 0, 0];
          horde.forEach(orc => {
            orc.survive = true;
          });
          const index = horde.map((v, i) => i);
          const vs = [];
          while (index.length > 1) {
            const a = index.splice(Math.floor(Math.random() * index.length), 1)[0];
            const b = index.splice(Math.floor(Math.random() * index.length), 1)[0];
            vs.push([a, b]);
          }
          const play = (black, white) => {
            const game = new Game([black, white]);
            game.remainRound = Math.min(game.remainRound, maxRounds);
            game.onEnd = (result) => {
              winnerStat[result]++;
              if (result === TIE) {
                black.score += 1;
                white.score += 1;
              } else if (result === BLACK) {
                black.score += 2;
              } else {
                white.score += 2;
              }
            };
            game.play();
          };
          for (let i = 0; i < vs.length; i++) {
            const [a, b] = vs[i];
            const pa = new PlayerAI(horde[a].core);
            const pb = new PlayerAI(horde[b].core);
            pa.score = 0;
            pb.score = 0;
            play(pa, pb);
            play(pb, pa);
            horde[a].survive = pa.score > 2;
            horde[b].survive = pb.score > 2;
            await new Promise(r => setTimeout(r, 10));
          }
          
          epoch++;
          console.log('epoch', epoch, horde.map(v => v.survive), maxRounds);
          if (winnerStat[TIE] / 2 > winnerStat[WHITE] + winnerStat[BLACK]) {
            maxRounds *= 2;
          } else if (maxRounds > 10) {
            horde = horde.filter(orc => orc.survive);
            maxRounds -= 5;
          }
          localStorage.goBangCore = JSON.stringify(horde[0].core);
          document.body.innerHTML = localStorage.goBangCore;
          const remain = horde.length;
          while (horde.length < HORDE_SIZE) {
            const pa = Math.floor(Math.random() * remain);
            const pb = Math.floor(Math.random() * remain);
            horde.push({
              core: inheritCore(crossCore(horde[pa].core, horde[pb].core)),
            });
          }
        }
      })();
    </script>
  </body>
</html>

